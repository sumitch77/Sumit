<!DOCTYPE html>

<html>
<head>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=UTF-8" >
  <title>Hello, World!</title>
</head>
<body>
  <h1><pre><b> Hello 
  Click below</b> 
  </pre></h1>
  <a href="new.html">
    <img src="" height="500">
  </a>
  
  <a href="https://docs.google.com/forms/d/e/1FAIpQLSeYDxHPOqoog49aHGQcV-z4Y94KarJl8RLNivIIM3xVM3Yl2g/viewform?usp=dialog" target="_blank">
    ye le mc form fill kr le </a>
  <br>
  
  <footer>
  
   <br>
    owner -
    <br>
  Instagram - <a href="https://www.instagram.com/sumit_ch_77?igsh=b2Y1ZndpeXkxemRo">Sumit_ch_77</a>
  <br>

  
  Facebook - <a href="https://www.facebook.com/profile.php?id=61560632547412&mibextid=ZbWKwL">Sumit Chaudhary</a>
  <br>
  Chess.com account - <a href="https://www.chess.com/member/nobody7728">Nobody7728</a>
  <br>
  BGMI ID - GodSumit
  <br>
  </footer>
  
  <p>
    include <stdlib.h>

// Define node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to insert at beginning
struct Node* insertAtBeginning(struct Node* head, int x) {
    // Step 1: Allocate memory for new node
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    
    // Step 2: Assign data
    newNode->data = x;

    // Step 3: Point new node to current head
    newNode->next = head;

    // Step 4: Update head
    head = newNode;

    return head;
}

// Function to print list
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;

    head = insertAtBeginning(head, 10);
    head = insertAtBeginning(head, 20);
    head = insertAtBeginning(head, 30);

    printList(head);

    return 0;
}

Algorithm: Insert Node at the End of Linked List
Input: Head pointer of the linked list, value x to insert
Output: Updated linked list with new node at end
Steps:
1.	Create a new node newNode.
2.	Assign newNode → data = x.
3.	Set newNode → next = NULL.
4.	If the list is empty (head == NULL), then
→ Set head = newNode.
→ Return head.
5.	Otherwise, initialize a pointer temp = head.
6.	Traverse the list until temp → next == NULL.
7.	Set temp → next = newNode.
8.	Return the head pointer.

#include <stdio.h>
#include <stdlib.h>

// Define node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to insert node at end
struct Node* insertAtEnd(struct Node* head, int x) {
    // Step 1: Allocate memory
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = x;
    newNode->next = NULL;

    // Step 2: If list is empty
    if (head == NULL) {
        head = newNode;
        return head;
    }

    // Step 3: Traverse till last node
    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }

    // Step 4: Attach new node at end
    temp->next = newNode;

    return head;
}

// Function to print list
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;

    head = insertAtEnd(head, 10);
    head = insertAtEnd(head, 20);
    head = insertAtEnd(head, 30);

    printList(head);

    return 0;
}

Algorithm: Insert Node at a Specified Location
Input: Head pointer of the linked list, value x to insert, position pos (1-based index).
Output: Updated linked list with new node inserted at given position.
Steps:
1.	Create a new node newNode.
2.	Assign newNode → data = x.
3.	If pos == 1:
o	Set newNode → next = head.
o	Update head = newNode.
o	Return head.
4.	Else:
o	Initialize pointer temp = head.
o	Repeat (pos-2) times: move temp = temp → next.
(Now temp is at the node just before the desired position.)
5.	Set newNode → next = temp → next.
6.	Set temp → next = newNode.
7.	Return the head pointer.
#include <stdio.h>
#include <stdlib.h>

// Define node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to insert node at a given position
struct Node* insertAtPosition(struct Node* head, int x, int pos) {
    struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));
    newNode->data = x;
    newNode->next = NULL;

    // Case 1: Insert at beginning
    if (pos == 1) {
        newNode->next = head;
        head = newNode;
        return head;
    }

    // Case 2: Insert at given position
    struct Node* temp = head;
    for (int i = 1; i < pos - 1 && temp != NULL; i++) {
        temp = temp->next;
    }

    if (temp == NULL) {
        printf("Position out of range!\n");
        free(newNode);
        return head;
    }

    newNode->next = temp->next;
    temp->next = newNode;

    return head;
}

// Function to print list
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    struct Node* head = NULL;

    // Insert nodes
    head = insertAtPosition(head, 10, 1); // 10
    head = insertAtPosition(head, 20, 2); // 10 -> 20
    head = insertAtPosition(head, 30, 2); // 10 -> 30 -> 20
    head = insertAtPosition(head, 40, 1); // 40 -> 10 -> 30 -> 20

    printList(head);

    return 0;
}




Algorithm: Delete Node at Beginning
Input: Head pointer of the linked list
Output: Updated head pointer after deleting the first node
Steps:
1.	If head == NULL, then the list is empty → print "List is empty" and return NULL.
2.	Otherwise:
o	Set temp = head.
o	Update head = head → next.
o	Free the memory of temp.
3.	Return the updated head.
#include <stdio.h>
#include <stdlib.h>

// Define node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to delete node from beginning
struct Node* deleteAtBeginning(struct Node* head) {
    if (head == NULL) {
        printf("List is empty. Nothing to delete.\n");
        return NULL;
    }

    struct Node* temp = head;
    head = head->next;  // Move head to next node
    free(temp);         // Free old head

    return head;
}

// Function to print list
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    // Create linked list manually: 10 -> 20 -> 30
    struct Node* head = (struct Node*) malloc(sizeof(struct Node));
    head->data = 10;
    head->next = (struct Node*) malloc(sizeof(struct Node));
    head->next->data = 20;
    head->next->next = (struct Node*) malloc(sizeof(struct Node));
    head->next->next->data = 30;
    head->next->next->next = NULL;

    printf("Original List: ");
    printList(head);

    head = deleteAtBeginning(head); // delete 10
    printf("After deleting first node: ");
    printList(head);

    return 0;
}

Algorithm: Delete Node at End
Input: Head pointer of the linked list
Output: Updated head pointer after deleting the last node
Steps:
1.	If head == NULL, then list is empty → print "List is empty" and return NULL.
2.	If head → next == NULL, then there is only one node:
o	Free head.
o	Return NULL.
3.	Otherwise:
o	Initialize pointer temp = head.
o	Traverse the list until temp → next → next == NULL (so temp points to the second-last node).
o	Free temp → next.
o	Set temp → next = NULL.
4.	Return head.
#include <stdio.h>
#include <stdlib.h>

// Define node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to delete node from end
struct Node* deleteAtEnd(struct Node* head) {
    // Case 1: Empty list
    if (head == NULL) {
        printf("List is empty. Nothing to delete.\n");
        return NULL;
    }

    // Case 2: Only one node
    if (head->next == NULL) {
        free(head);
        return NULL;
    }

    // Case 3: More than one node
    struct Node* temp = head;
    while (temp->next->next != NULL) {
        temp = temp->next;
    }

    free(temp->next);   // Delete last node
    temp->next = NULL;  // Set new end to NULL

    return head;
}

// Function to print list
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    // Create linked list manually: 10 -> 20 -> 30
    struct Node* head = (struct Node*) malloc(sizeof(struct Node));
    head->data = 10;
    head->next = (struct Node*) malloc(sizeof(struct Node));
    head->next->data = 20;
    head->next->next = (struct Node*) malloc(sizeof(struct Node));
    head->next->next->data = 30;
    head->next->next->next = NULL;

    printf("Original List: ");
    printList(head);

    head = deleteAtEnd(head); // delete 30
    printf("After deleting last node: ");
    printList(head);

    return 0;
}
	
Algorithm: Delete Node at a Specified Location
Input: Head pointer of the linked list, position pos (1-based index).
Output: Updated head pointer after deleting the node at given position.
Steps:
1.	If head == NULL → print "List is empty" and return NULL.
2.	If pos == 1:
o	Store temp = head.
o	Update head = head → next.
o	Free temp.
o	Return head.
3.	Otherwise:
o	Initialize pointer temp = head.
o	Traverse the list until the node just before the one to delete (pos-2 times).
o	If temp == NULL or temp → next == NULL, print "Position out of range" and return head.
o	Store toDelete = temp → next.
o	Update temp → next = toDelete → next.
o	Free toDelete.
4.	Return head.
#include <stdio.h>
#include <stdlib.h>

// Define node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to delete node at a given position
struct Node* deleteAtPosition(struct Node* head, int pos) {
    if (head == NULL) {
        printf("List is empty. Nothing to delete.\n");
        return NULL;
    }

    // Case 1: Delete first node
    if (pos == 1) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    // Case 2: Delete at given position
    struct Node* temp = head;
    for (int i = 1; i < pos - 1 && temp != NULL; i++) {
        temp = temp->next;
    }

    // If position is invalid
    if (temp == NULL || temp->next == NULL) {
        printf("Position out of range!\n");
        return head;
    }

    struct Node* toDelete = temp->next;
    temp->next = toDelete->next;
    free(toDelete);

    return head;
}

// Function to print list
void printList(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Example usage
int main() {
    // Create linked list manually: 10 -> 20 -> 30 -> 40
    struct Node* head = (struct Node*) malloc(sizeof(struct Node));
    head->data = 10;
    head->next = (struct Node*) malloc(sizeof(struct Node));
    head->next->data = 20;
    head->next->next = (struct Node*) malloc(sizeof(struct Node));
    head->next->next->data = 30;
    head->next->next->next = (struct Node*) malloc(sizeof(struct Node));
    head->next->next->next->data = 40;
    head->next->next->next->next = NULL;

    printf("Original List: ");
    printList(head);

    head = deleteAtPosition(head, 2); // delete 20
    printf("After deleting at position 2: ");
    printList(head);

    head = deleteAtPosition(head, 1); // delete 10
    printf("After deleting at position 1: ");
    printList(head);

    head = deleteAtPosition(head, 5); // invalid position
    printf("After trying invalid delete: ");
    printList(head);

    return 0;
}

Algorithm: Add Two Polynomials using Linked List
Input: Two polynomials poly1 and poly2 represented as linked lists.
Output: A new polynomial linked list polySum representing their sum.
 
Steps:
1.	Create a new linked list polySum = NULL.
2.	Initialize two pointers: p1 = poly1, p2 = poly2.
3.	While both p1 != NULL and p2 != NULL:
o	If p1->pow == p2->pow:
	Create a node with coef = p1->coef + p2->coef and pow = p1->pow.
	Append this node to polySum.
	Move both p1 and p2 forward.
o	Else if p1->pow > p2->pow:
	Copy p1’s term to polySum.
	Move p1 forward.
o	Else (p2->pow > p1->pow):
	Copy p2’s term to polySum.
	Move p2 forward.
4.	If any terms remain in p1 or p2, append them directly to polySum.
5.	Return polySum.

  </p>
  
  
</body>

</html>
